// benchmarkRoutes.js
const express = require('express');
const router = express.Router();
const pool = require('../db');
const auth = require('../middleware/auth');

// POST route remains unchanged...
router.post('/calculate', auth, async (req, res) => {
    console.log('Calculating sector benchmarks...');
    const { sectorId, internalWeight = 30, externalWeight = 70 } = req.body;
    const connection = await pool.getConnection();
    try {
        await connection.beginTransaction();
        let sectors = [];
        if (sectorId) {
            const [rows] = await connection.query(
                'SELECT * FROM sector WHERE Sector_ID = ?',
                [sectorId]
            );
            sectors = rows;
        } else {
            const [allSectors] = await connection.query('SELECT * FROM sector');
            sectors = allSectors;
        }
        const results = [];
        for (const sectorObj of sectors) {
            const sid = sectorObj.Sector_ID;
            // Calculate internal average from risk_score for this sector
            const [avgRows] = await connection.query(
                `
                SELECT AVG(rs.Score_Value) AS internalAvg
                FROM risk_score rs
                JOIN user u ON rs.User_ID = u.User_ID
                WHERE u.Sector_ID = ?
                `,
                [sid]
            );
            const internalAvg = avgRows[0].internalAvg || 0;
            // Fetch external data from external_benchmarks for this sector
            const [extRows] = await connection.query(
                `
                SELECT external_score, source_reference
                FROM external_benchmarks 
                WHERE sector_id = ?
                ORDER BY updated_at DESC
                LIMIT 1
                `,
                [sid]
            );
            let externalScore = 0;
            let externalSource = null;
            if (extRows.length > 0) {
                externalScore = extRows[0].external_score;
                externalSource = extRows[0].source_reference;
            }
            // Calculate the blended score: 30% internal + 70% external
            const intWeight = parseFloat(internalWeight) / 100.0;
            const extWeight = parseFloat(externalWeight) / 100.0;
            const blendedScore = (internalAvg * intWeight) + (externalScore * extWeight);
            // Upsert into sector_benchmark table
            await connection.query(
                `
                INSERT INTO sector_benchmark
                    (sector_id, internal_avg, external_score, blended_score, source_reference)
                VALUES (?, ?, ?, ?, ?)
                ON DUPLICATE KEY UPDATE
                    internal_avg = VALUES(internal_avg),
                    external_score = VALUES(external_score),
                    blended_score = VALUES(blended_score),
                    source_reference = VALUES(source_reference),
                    updated_at = CURRENT_TIMESTAMP
                `,
                [sid, internalAvg, externalScore, blendedScore, externalSource]
            );
            results.push({
                sectorId: sid,
                sectorName: sectorObj.Sector_Name,
                internalAvg,
                externalScore,
                blendedScore,
                sourceReference: externalSource
            });
        }
        await connection.commit();
        console.log('Benchmark calculation complete:', results);
        return res.json({
            message: 'Sector benchmarks calculated successfully',
            data: results
        });
    } catch (err) {
        await connection.rollback();
        console.error('Error calculating benchmarks:', err);
        return res.status(500).json({ error: 'Failed to calculate benchmarks' });
    } finally {
        connection.release();
    }
});

// NEW GET route: Returns benchmark info only for the specified userâ€™s sector.
// We use a route parameter (/:userId) for consistency with your recommendations route.
router.get('/:userId', auth, async (req, res) => {
    const { userId } = req.params;
    try {
        // Look up the user in the database
        const [userRows] = await pool.query('SELECT Sector_ID FROM user WHERE User_ID = ?', [userId]);
        if (!userRows.length) {
            return res.status(404).json({ error: 'User not found' });
        }
        const sectorId = userRows[0].Sector_ID;
        // Fetch benchmark data for this sector
        const [benchmarks] = await pool.query(
            `
            SELECT sb.*, s.Sector_Name
            FROM sector_benchmark sb
            JOIN sector s ON sb.sector_id = s.Sector_ID
            WHERE sb.sector_id = ?
            ORDER BY sb.updated_at DESC
            `,
            [sectorId]
        );
        return res.json(benchmarks);
    } catch (err) {
        console.error('Error fetching sector benchmarks:', err);
        return res.status(500).json({ error: 'Failed to fetch sector benchmarks' });
    }
});

module.exports = router;

